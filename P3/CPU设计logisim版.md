## 单周期CPU设计草稿

### PC模块：

将寄存器的初值赋值为0x0000_0000，在输出pc的时候加上3000，这样在异步复位的时候就避免了奇奇怪怪的振荡bug。

通过一个多路选择器来实现顺序执行指令和分支的跳转指令，在本版本中未实现j型指令，故mux只有两个端口，通过PCSrc来确定PC的计算方式。

| PCSrc | 含义                                            |
| ----- | ----------------------------------------------- |
| 000   | 顺序计算pc，pc=pc+4                             |
| 001   | beq分支计算，pc=pc+4+sign_extend(offset\|\|0^2) |
| 010   | j指令跳转，pc=pc31...28\|\|instr\|\|0^2         |
|       |                                                 |



### IM模块:

PC地址范围:**0x0000_3000-0x0000_6FFF**

ROM对应的地址范围从0开始，因为PC是+4的，所以低2位默认一直是0，即取到ROM从第2位开取，才能实现对应右移2位的操作，且做减法发现，得到的差值最大是3FFF,即14.15位恒为0，故从PC到ROM地址的读取需要的是2-13位，操作已更新在logisim中

| 信号名 | 方向 | 描述              |
| ------ | ---- | ----------------- |
| pc     | I    | 程序计数器        |
| instr  | O    | 从ROM中读出的指令 |



### Instr_split模块:

将IM模块中取得的指令导入模块，让封装的模块完成所需位数的分叉处理。本版本中实现了opcode,rs,rt,rd,funct,immediate(16bit)的分离。从上到下的顺序分别是:opcode,funct,25...21,20...16,15...11,immediate,25...0(为j型指令的26位立即数做准备)。

| 信号名    | 方向 | 描述                    |
| --------- | ---- | ----------------------- |
| instr     | I    | 从ROM中读出的指令       |
| opcode    | O    | 对应mips汇编机器码表示  |
| funct     | O    |                         |
| 25...21   | O    |                         |
| 20...16   | O    |                         |
| 15...11   | O    |                         |
| immediate | O    |                         |
| 25...0    | O    | 未扩展的j型指令的立即数 |



### GRF模块：

借用P0的GRF模块即可，注意好输入输出端口分别是什么即可。

| 信号名 | 方向 | 描述                                           |
| ------ | ---- | ---------------------------------------------- |
| clk    | I    | 时钟                                           |
| reset  | I    | 1:复位，0：无效                                |
| WE     | I    | 1:可写，0：不能写                              |
| A1     | I    | 指定特定的寄存器，将数据读入到RD1中            |
| A2     | I    | 指定特定的寄存器，将数据读入到RD2中            |
| A3     | I    | 指定特定的寄存器，将WD的数据写入到A3中(WE=1时) |
| WD     | I    | 32位数据输入信号                               |
| RD1    | O    | 输出A1读出的数据                               |
| RD2    | O    | 输出A2读出的数据                               |



### Control模块：

根据opcode和funct字段来决定一系列输出信号。

用与或门阵列生成识别与匹配逻辑

与门进行操作是什么的识别(除R型外，其他型指令凭借opcode即可识别，与门输出为1，即告诉我们这条指令需要进行的ALU操作是什么)，(R型先借助000000的opcode模块识别它是R型，再借助funct字段识别出到底是什么操作)。

或门是识别这条指令到底是什么操作之后，生成一系列输出信号，反馈到datapath供datapath的使用。

**想清楚每个输出信号代表的含义，再想想新增的指令需要哪些输出信号，添加对应的信号到或门上，即可实现在这个操作的时候，我们会有对应的信号帮助我们实现想要的操作。**

ALUOp方面，选择了一个优先编码器，决定了该操作需要的运算是什么，再将ALUOp信号接入ALU模块，帮助我们得到ALUResult的运算结果。

| 信号名      | 方向 | 描述                                                         |
| ----------- | ---- | :----------------------------------------------------------- |
| opcode      | I    | 对应mips汇编机器码格式                                       |
| funct       | I    | 对应mips汇编机器码格式                                       |
| MemtoReg    | O    | 1:从内存中取得数据，是内存单元保留的值，0:从ALU运算单元取得的ALUResult |
| MemWrite    | O    | 1：对内存进行写操作，0：写操作无效                           |
| ALUOp[2:0]  | O    | 决定了运算操作                                               |
| ALUSrc      | O    | 1：用立即数进行操作，0：用RD2进行操作(寄存器)                |
| RegDst[2:0] | O    | 001：GRF写入的寄存器的是rd寄存器，000：GRF写入的寄存器的是rt寄存器(空出来的地方供新增指令需要写入指定的寄存器例如GPR[31]) |
| RegWrite    | O    | 1：可以进行写入操作，0：不能进行写入操作                     |
| ExtOp       | O    | 1:对立即数符号扩展，0：0扩展                                 |
| PCSrc[2:0]  | O    | 决定PC的计算方式                                             |
| DMOp[2:0]   | O    | 决定DM的读写方式，是以字还是半字还是字节为单位进行读写。                                          000:字方式，lw,sw指令，001:半字方式，lh,sh指令，010:字节方式,lb,sb指令 |

### EXT模块：

将immediate和ExtOp导入，在本版本中，若ExtOp为1，则代表需要进行符号扩展，我采用sign_extender实现，若ExtOp为0代表此立即数是无符号的，直接进行0扩展即可。

| 信号名    | 方向 | 描述                 |
| --------- | ---- | -------------------- |
| imm[15:0] | I    | 16位立即数           |
| ExtOp     | I    | 1:符号扩展，0：0扩展 |
| imm[31:0] | O    | 完成扩展的32位立即数 |



### ALU模块：

| ALUControl | Operation  |
| ---------- | ---------- |
| 000        | 与         |
| 001        | 或         |
| 010        | 加         |
| 110        | 减         |
| 011        | lui,高16位 |
|            |            |
|            |            |
|            |            |

### DM模块：

使用RAM实现，地址范围为0x0000_0000-0x0000_2fff

| 信号名    | 方向 | 描述                                                         |
| --------- | ---- | ------------------------------------------------------------ |
| address   | I    | 从RAM读出的地址                                              |
| writedata | I    | 写入的数据                                                   |
| clk       | I    | 时钟信号                                                     |
| WE        | I    | 1：能写入，0：不能写入                                       |
| reset     | I    | 1：RAM清0，0：无效                                           |
| DMOp[2:0] | I    | 000:无所谓，因为WE会恒为0，001:lw,sw指令,010:lh,sh指令,011:lb,sb指令 |
| readdata  | O    | 从RAM读出的数据                                              |

## 思考题

1.状态转移：PC,IM,Control,EXT,ALU,Instr_split

   状态存储：GRF,DM

2.合理。IM是根据pc的值在rom中读出已写入rom的指令的机器码，而IM是不需要在cpu运行的时候被改变，所以只需要具有只读功能即可，故选用ROM是合理的。GRF采用32个寄存器，减少了对内存的直接访问，加快了读写的速度，故GRF采用registers也是合理的。DM采用RAM作为内存也是合理的，一方面需要被读，一方面具有可写功能，RAM恰好满足了这点功能。

3.设计了Instr_split模块，是将从IM模块读出的指令放入此模块中，让这模块自动完成位数的分叉，减少裸露在外的线避免连错，至于之后操作对数据位数的选取，只需要增加输出端口便可方便的实现。

4.nop空指令机器码是0x0000_0000,它被用于空循环，我们在读到此条指令时无需进行任何操作，自然真值信号表也就不需要它。

5.不足之处：

sw,lw指令的offset没有考虑负数，并且从内存中读到寄存器的操作是不完整的，应对32个寄存器都进行操作，从而检验操作的正确性

beq指令的跳转目标考虑的情况太少，没有考虑到跳转的目标在此跳转指令之前，即pre给出的只考虑了往后跳转的情况。
